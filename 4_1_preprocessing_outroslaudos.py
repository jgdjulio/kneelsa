# -*- coding: utf-8 -*-
"""4.1.PreProcessing_outroslaudos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IfdveaPNqCfKDtzr2Td2Jyxa1Ea7r8Jd
"""

import pydicom
import glob
import numpy as np
import matplotlib.pyplot as plt

"""## Ler imagens em dicom e transforma-las em arrays de pixels"""

#para ler todas as imagens da pasta
direito_1 = []
paths = glob.glob("padrao_ouro/Direito/1/IM*.dcm")
for path in paths:
    dataset = pydicom.dcmread(path)
    direito_1.append(dataset.pixel_array)

#para ler todas as imagens da pasta
direito_0 = []
paths = glob.glob("padrao_ouro/Direito/0/IM*.dcm")
for path in paths:
    dataset = pydicom.dcmread(path)
    direito_0.append(dataset.pixel_array)

#para ler todas as imagens da pasta
esquerdo_0 = []
paths = glob.glob("padrao_ouro/Esquerdo/0/IM*.dcm")
for path in paths:
    dataset = pydicom.dcmread(path)
    esquerdo_0.append(dataset.pixel_array)

#para ler todas as imagens da pasta
esquerdo_1 = []
paths = glob.glob("padrao_ouro/Esquerdo/1/IM*.dcm")
for path in paths:
    dataset = pydicom.dcmread(path)
    esquerdo_1.append(dataset.pixel_array)

"""## Cortar imagens em direito e esquerdo"""

def cortar_lado(im_arr, lado='direito'):
    altura = len(im_arr)
    largura = len(im_arr[1])
    metade = int(largura/2)
    if lado == 'direito':
        im_arr = im_arr[0:altura, 0:metade]
    else:
        im_arr = im_arr[0:altura, metade:largura]
    return(im_arr)

e1 = []
for img in esquerdo_1:
    e1.append(cortar_lado(img, lado='esquerdo'))
    
e0 = []
for img in esquerdo_0:
    e0.append(cortar_lado(img, lado='esquerdo'))

d1 = []
for img in direito_1:
    d1.append(cortar_lado(img, lado='direito'))

d0 = []
for img in direito_0:
    d0.append(cortar_lado(img, lado='direito'))

for img_arr in e1:
    plt.imshow(img_arr, cmap="gray")
    plt.show()

"""## Tirar bordas pretas"""

def crop_image(img,tol=0):
    # img is 2D image data
    # tol  is tolerance
    mask = img>tol
    return img[np.ix_(mask.any(1),mask.any(0))]

for i, img in enumerate(e1):
    e1[i] = crop_image(e1[i],tol=100)
    
for i, img in enumerate(e0):
    e0[i] = crop_image(e0[i],tol=100)

for i, img in enumerate(d0):
    d0[i] = crop_image(d0[i],tol=100)

for i, img in enumerate(d1):
    d1[i] = crop_image(d1[i],tol=100)

for img_arr in e1:
    plt.imshow(img_arr, cmap="gray")
    plt.show()

"""## Cortar todas as fotos do mesmo tamanho"""

#pip install opencv-python

import math
import cv2

def default_preprocessing(image, 
                          min_hw_ratio = 1, 
                          output_width = 299, 
                          output_height = 299):

    r, c = image.shape
    if c>r:
        # Trim equal columns from left and right to get a square image
        image_hw_ratio = c/r
        c_to_keep = r * min_hw_ratio
        c_to_delete = c - c_to_keep
        remove_from_top = int(math.ceil(c_to_delete/2))
        remove_from_bottom = int(math.floor(c_to_delete/2))
        image_top_bottom_trimmed = image[:,remove_from_top:(r-remove_from_bottom)]
        
    if r>c:
        # Trim equal rows from top and bottom to get a square image
        image_hw_ratio = r/c
        r_to_keep = c * min_hw_ratio
        r_to_delete = r - r_to_keep
        remove_from_top = int(math.ceil(r_to_delete/2))
        remove_from_bottom = int(math.floor(r_to_delete/2))
        image_top_bottom_trimmed = image[remove_from_top:(r-remove_from_bottom),:]

    # resample to get the desired image size
    image_resampled = cv2.resize(image_top_bottom_trimmed, \
                                 dsize=(output_width, output_height), \
                                 interpolation=cv2.INTER_CUBIC)
    
    # Normalize pixel values to take the range [0,1]
    #image_clean = image_resampled - np.mean(image_resampled)
    #image_clean = image_clean / np.std(image_clean)
    #image_clean = ((image_clean - np.min(image_clean)) \
    #               / (np.max(image_clean) - np.min(image_clean)))  

    # Stack into three channels
    #image_clean_stacked = np.dstack((image_clean, image_clean, image_clean))
    #image_clean_stacked = np.moveaxis(image_clean_stacked, -1, 0)  
    
    # Implement ImageNet Standardization
    #imagenet_mean = np.array([0.485, 0.456, 0.406]).reshape((3,1,1))
    #imagenet_std = np.array([0.229, 0.224, 0.225]).reshape((3,1,1))
    #image_clean_stacked = (image_clean_stacked - imagenet_mean) / imagenet_std
    
    #return image_clean_stacked
    return image_resampled

for i, img in enumerate(e1):
    e1[i] = default_preprocessing(e1[i])
    
for i, img in enumerate(e0):
    e0[i] = default_preprocessing(e0[i])

for i, img in enumerate(d0):
    d0[i] = default_preprocessing(d0[i])

for i, img in enumerate(d1):
    d1[i] = default_preprocessing(d1[i])

for img_arr in e1:
    plt.imshow(img_arr, cmap="gray")
    plt.show()

"""## Salvando em pastas"""

from PIL import Image

def salvar_pastas(array_imgs, nomes_arquivos, lado='e', label=1, pasta='train'):
    for i,img in enumerate(array_imgs):
        if i != 10000:
            print(i)
            im = Image.fromarray(img)
            nome = nomes_arquivos[i].split('.')[0]
            #im.save('padrao_ouro_pr'+'/'+pasta+'/'+str(label)+'/'+nome+'_'+lado+'.jpeg')
            im.save('padrao_ouro_pr/'+str(label)+'/'+nome+'_'+lado+'.jpeg')

import pickle
#esquerdo_0 = []
with open("esquerdo_0", "rb") as fp:   #Pickling
    esquerdo_0 = pickle.load(fp)

with open("esquerdo_1", "rb") as fp:   #Pickling
    esquerdo_1 = pickle.load(fp)

with open("direito_0", "rb") as fp:   #Pickling
    direito_0 = pickle.load(fp)
    
with open("direito_1", "rb") as fp:   #Pickling
    direito_1 = pickle.load(fp)

#salvar_pastas(d0, direito_0, lado='d', label=0, pasta='train')
salvar_pastas(d0, direito_0, lado='d', label=0, pasta='test')

len(direito_0)

salvar_pastas(e0, esquerdo_0, lado='e', label=0, pasta='train')
#salvar_pastas(e0, esquerdo_0, lado='e', label=0, pasta='test')

salvar_pastas(e1, esquerdo_1, lado='e', label=1, pasta='train')
#salvar_pastas(e1, esquerdo_1, lado='e', label=1, pasta='test')

salvar_pastas(d1, direito_1, lado='d', label=1, pasta='train')
#salvar_pastas(d1, direito_1, lado='d', label=1, pasta='test')

